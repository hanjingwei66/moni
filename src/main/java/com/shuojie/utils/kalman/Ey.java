package com.shuojie.utils.kalman;

public class Ey {
    public static void main(String[] args){

	double[] rr={

/*            120.2620034135,120.2619658625,120.2619336760,120.2620356000,120.2621804393,
            120.2624003804,120.2627705252,120.2632318652,120.2635483659,120.2639131463,
            120.2642725623,120.2647285378,120.2648733771,120.2650235808,120.2651791489,*/

            120.26200,120.26196,120.26193,120.26203,120.26218,
            120.26240,120.26277,120.26323,120.26354,120.26391,
            120.26427,120.26472,120.26487,120.26502,120.26517,
            /* 120.0223892,120.0223249,120.0222820,120.0222551,120.0222712,120.0222766,
            120.0223249,120.0223195,120.0223141,120.0223195,120.0223195,120.0223195,120.0223195,
            120.0223195,120.0223195,120.0223249,120.0223517,120.0223785,120.0223785,120.0223785,
            120.0223785,120.0223785,120.0223785,120.0223785,120.0223785,120.0223785,120.0223785,
            120.0223785,120.0223785,120.0223785,120.0223785,120.0223785,120.0223785,120.0223785,
            120.0223785,120.0223517,120.0221800,120.0219762,120.0218796,120.0219386,120.0218528,
            120.0216221,120.0212466,120.0209516,120.0207692,120.0206512,120.0205761,120.0205010,
            120.0204956,120.0204259,120.0204044,120.0204044,120.0204527,120.0204902,120.0208818,
            120.0216060,120.0225126,120.0234675,120.0244277,120.0252860,120.0260585,120.0270187,
            120.0279092,120.0286173,120.0294166,120.0302106,120.0310796,120.0320130,120.0324958,
            120.0325495,120.0325924,120.0327372,120.0329625,120.0332039,120.0332897,120.0334239,
            120.0334829,120.0335258,120.0336438,120.0339335,120.0341856,120.0344216,120.0347167,
            120.0349581,120.0352424,120.0355803,120.0358808,120.0361436,120.0362616,120.0365781,
            120.0370395,120.0372487,120.0375008,120.0377959,120.0381714,120.0386005,120.0389546,
            120.0392121,120.0394266,120.0396573,120.0401079,120.0406283,120.0412881,120.0419050,
            120.0422000,120.0421142,120.0421142,120.0421088,120.0421088,120.0421088,120.0420552,
            120.0420445,120.0420391,120.0419533,120.0418889,120.0420284,120.0422966,120.0426828,
            120.0431925,120.0436913,120.0442492,120.0448125,120.0452846,120.0455206,120.0452417,
            120.0447750,120.0443512,120.0441473,120.0444263,120.0447857,120.0452792,120.0457674,
            120.0461965,120.0464218,120.0467222,120.0469851,120.0471568,120.0473070,120.0475859,
            120.0479131,120.0482189,120.0483423,120.0483798,120.0483101,120.0482618,120.0484067,
            120.0489431,120.0495707,120.0502949,120.0511854,120.0517541,120.0520545,120.0524139,
            120.0528699,120.0532346,120.0535082,120.0537818,120.0540286,120.0542110,120.0543022,
            120.0543129,120.0543129,120.0543129,120.0544095,120.0546455,120.0549620,120.0553214,
            120.0556486,120.0559169,120.0562173,120.0565499,120.0568717,120.0570756,120.0572150,
            120.0573652,120.0575047,120.0576710,120.0577944,120.0579339,120.0580358,120.0580734,
            120.0580734,120.0580304,120.0579500,120.0582879,120.0588941,120.0223892,120.0223249,
            120.0222820,120.0222551,120.0222712,120.0222766,120.0223249,120.0223195,120.0223141,
            120.0223195,120.0223195,120.0223195,120.0223195,120.0223195,120.0223195,120.0223249,
            120.0223517,120.0223785,120.0223785,120.0223785,120.0223785,120.0223785,120.0223785,
            120.0223785,120.0223785,120.0223785,120.0223785,120.0223785,120.0223785,120.0223785,
            120.0223785,120.0223785,120.0223785,120.0223785,120.0223785,120.0223517,120.0221800,
            120.0219762,120.0218796,120.0219386,120.0218528,120.0216221,120.0212466,120.0209516,
            120.0207692,120.0206512,120.0205761,120.0205010,120.0204956,120.0204259,120.0204044,
            120.0204044,120.0204527,120.0204902,120.0208818,120.0216060,120.0225126,120.0234675,
            120.0244277,120.0252860,120.0260585,120.0270187,120.0279092,120.0286173,120.0294166,
            120.0302106,120.0310796,120.0320130,120.0324958,120.0325495,120.0325924,120.0327372,
            120.0329625,120.0332039,120.0332897,120.0334239,120.0334829,120.0335258,120.0336438,
            120.0339335,120.0341856,120.0344216,120.0347167,120.0349581,120.0352424,120.0355803,
            120.0358808,120.0361436,120.0362616,120.0365781,120.0370395,120.0372487,120.0375008,
            120.0377959,120.0381714,120.0386005,120.0389546,120.0392121,120.0394266,120.0396573,
            120.0401079,120.0406283,120.0412881,120.0419050,120.0422000,120.0421142,120.0421142,
            120.0421088,120.0421088,120.0421088,120.0420552,120.0420445,120.0420391,120.0419533,
            120.0418889,120.0420284,120.0422966,120.0426828,120.0431925,120.0436913,120.0442492,
            120.0448125,120.0452846,120.0455206,120.0452417,120.0447750,120.0443512,120.0441473,
            120.0444263,120.0447857,120.0452792,120.0457674,120.0461965,120.0464218,120.0467222,
            120.0469851,120.0471568,120.0473070,120.0475859,120.0479131,120.0482189,120.0483423,
            120.0483798,120.0483101,120.0482618,120.0484067,120.0489431,120.0495707,120.0502949,
            120.0511854,120.0517541,120.0520545,120.0524139,
            120.0528699,120.0532346,120.0535082,120.0537818,120.0540286,120.0542110,120.0543022,
            120.0543129,120.0543129,120.0543129,120.0544095,120.0546455,120.0549620,120.0553214,
            120.0556486,120.0559169,120.0562173,120.0565499,120.0568717,120.0570756,120.0572150,
            120.0573652,120.0575047,120.0576710,120.0577944,120.0579339,120.0580358,120.0580734,
            120.0580734,120.0580304,120.0579500,120.0582879,120.0588941*/
			};//response

        int n=rr.length;//number of data values		//数据值个数
        double[] rt=new double[n];//t ordinates		//t纵坐标
        for(int i=0;i<n;i++){
            rt[i]=i+1;
        }

        int m=2;//derivative in penalty		//导数在惩罚
        //m=2 produces a cubic smoothing spline
        //m=2生成一个三次平滑样条

        double lam=124.3984;	//smoothing parameter value		//平滑参数值
        //For this data and this choice of lambda, the same result will
        //对于这个数据和lambda的选择，结果是一样的
        //be obtained using spar=1 in the R smooth.spline function with
        //在R光滑中使用spar=1得到。样条函数逆向
        //all.knots=T

        vector y=new vector(rr);//convert array to vector	//将数组转换为向量
        vector tau=new vector(rt);//convert array to vector


        //ss objects for processing y
        //用于处理y的ss对象
        ss[] s=new ss[n];
        //ss objects for processing polynomial matrix
        //处理多项式矩阵的ss对象
        ss[][] sT=new ss[n][m];
        //polynomial matrix
        //多项式矩阵
        matrix T=new matrix(tau,m);
        //initialize forward recusion for y
        //初始化y的前向循环
        s[0]=new ss(1,tau,m,lam);
        s[0].forward(new matrix(m,0), new vector(m,0),new vector(y.value(0)));

        //initialize forward recusion for T
        //初始化T的前向循环
        for(int j=0;j<m;j++){
            sT[0][j]=new ss(1,tau,m,lam);
            sT[0][j].forward(new matrix(m,0), new vector(m,0),new vector(T.value(0,j)));
        }
        //forward recursion
        //向前递归
        for(int i=1;i<n;i++){
            s[i]=new ss(i+1,tau,m, lam);
            s[i].forward(s[i-1].GetS(),s[i-1].Getx(),new vector(y.value(i)));for(int j=0;j<m;j++){
                sT[i][j]=new ss(i+1,tau,m,lam);
                sT[i][j].forward(sT[i-1][j].GetS(), sT[i-1][j].Getx(),new vector(T.value(i,j)));
            }
        }
        //define xn and Sn for s[n-1] for use in subsequent recusions
        //为s[n-1]定义xn和Sn，以便在以后的重复中使用
        s[n-1].Setxntox();
        s[n-1].SetSntoS();

        //initialize backward recusion for y
        //初始化y的向后回缩
        s[n-2].smooth(new vector(m,0),new matrix(m,0), s[n-1].GetHTRinv(), s[n-1].Geteps());

        //initialize backward recusion for T
        //初始化T的反循环
        for(int j=0;j<m;j++){
            sT[n-1][j].Setxntox();
            sT[n-2][j].smooth(new vector(m,0),new matrix(m,0), sT[n-1][j].GetHTRinv(), sT[n-1][j].Geteps());
        }
        //backward recursion
        //向后递归
        for(int i=n-3;i>=0;i--){
            s[i].smooth(s[i+1].Geta(), s[i+1].GetA(),s[i+1].GetHTRinv(), s[i+1].Geteps());
            for(int j=0;j<m;j++){
                sT[i][j].smooth(sT[i+1][j].Geta(), sT[i+1][j].GetA(),sT[i+1][j].GetHTRinv(), sT[i+1][j].Geteps());
            }
        }

        //now compute the fit and leverage values
        //现在计算fit和leverage值

        //Ttil=T-fit_to_T
        matrix Ttil=new matrix(n,m,0);
        vector fit=new vector(n,0);
        for(int i=0;i<n;i++){
            fit.setValue(i,s[i].Getxn().value(0));
            for(int j=0;j<m;j++)
                Ttil.setValue(i,j,T.value(i,j)-sT[i][j].Getxn().value(0));
        }
        vector g_0=Ttil.trans().times(y);

        //explicitely evaluate the m by m matrix ${T^T\Sigma_{y_0}^{-1}T)^{-1}$ here
        //这里明确地计算m×m矩阵${T^T\Sigma_{y_0}^{-1}T)^{-1}$
        matrix V=Ttil.trans().times(T).chol(new matrix(m,1));

        fit=fit.plus(Ttil.times(V.times(g_0)));

        System.out.println("The fit");
        fit.printVector();


        vector lev=new vector(n, 0);//leverage values
        vector temp;//temporary storage vector of length m 	//长度为m的临时存储向量
        for(int j=0;j<n;j++){
            temp=new vector(Ttil.trans(),j);//extract jth row from Ttil
            lev.setValue(j,s[j].GetSn().value(0,0)+temp.inner(V.times(temp)));
        }
        lev.printVector();
        System.out.println("Levarage values");

    }
}
